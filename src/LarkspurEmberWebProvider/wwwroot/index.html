<!DOCTYPE html>
<html lang="en" xmlns="http://www.w3.org/1999/xhtml">
<head>
    <meta charset="utf-8" />
    <title>Larkspur</title>
    <style type="text/css">
        body, html {
            margin: 0;
            padding: 0;
            font-family: roboto, Arial, Helvetica, sans-serif !important;
            -webkit-font-smoothing: subpixel-antialiased;
            -ms-text-size-adjust: 100%;
            -webkit-text-size-adjust: 100%;
            line-height: 1;
            background: #004dca;
            color: #e7f5ff;
        }
        .conf-container {
            margin: 0 auto;
            padding: 3vh 5vw;
            margin: 0;
        }
        a {
            color: #4263e6;
            text-decoration: underline;
            cursor:pointer;
        }
        a:hover {
            color: #9a42ce;
            text-decoration: underline;
        }
        .small {
            font-size: 12px;
        }
        .unit {
            margin-top: 15px;
        }
        button {
            background: #5f5f5f;
            border: 1px solid #313131;
            color: #fff;
            padding: 0 1em;
            min-height: 35px;
            font-size: 1em;
            cursor: pointer;
            -webkit-transition: all 0.2s;
            -moz-transition: all 0.2s;
            transition: all 0.2s;
            border-radius: 2px;
        }
        button:hover {
            background: #333333;
        }
        input, select {
            border: 0;
            padding: 0 0 0 10px;
            background: #fff;
            border: 1px solid #4c4c4c;
            font-size: 1em;
            border-radius: 0;
            outline: 0;
            -webkit-appearance: none;
            height: 35px;
            box-sizing: border-box;
            border-radius: 2px;
            min-width: 35%;
        }
        input[type="range"] {
            -webkit-appearance: none;
            height: 10px;
            border-radius: 5px;
            background: #7530a0;
            background: rgba(117, 48, 160, 0.5);
            outline: none;
            padding: 0;
            margin: 1rem 0;
            width: 100%;
        }
        input[type="range"]::-webkit-slider-thumb {
            -webkit-appearance: none;
                    appearance: none;
            width: 40px;
            height: 40px;
            border-radius: 50%;
            background: #2c3e50;
            cursor: pointer;
            -webkit-transition: background .15s ease-in-out;
            transition: background .15s ease-in-out;
        }
        input[type="range"]::-webkit-slider-thumb:hover {
            background: #1abc9c;
        }
        input[type="range"]:active::-webkit-slider-thumb {
            background: #1abc9c;
        }
        input[type="range"]::-moz-range-thumb {
            width: 40px;
            height: 40px;
            border: 0;
            border-radius: 50%;
            background: #2c3e50;
            cursor: pointer;
            -moz-transition: background .15s ease-in-out;
            transition: background .15s ease-in-out;
        }
        input[type="range"]::-moz-range-thumb:hover {
            background: #1abc9c;
        }
        input[type="range"]:active::-moz-range-thumb {
            background: #1abc9c;
        }
        input[type="range"]:focus::-webkit-slider-thumb {
            box-shadow: 0 0 0 3px #fff, 0 0 0 6px #1abc9c;
        }
        select {
            padding: 0 30px 0 10px;
            background-image: linear-gradient(45deg, transparent 50%, #000000 50%), linear-gradient(135deg, black 50%, transparent 50%), linear-gradient(to right, white, white);
            background-position: calc(100% - 16px) calc(0.8em + 2px), calc(100% - 11px) calc(0.8em + 2px), 100% 0;
            background-size: 5px 5px, 5px 5px, 2.5em 2.5em;
            background-repeat: no-repeat;
        }
        .screen {
            color: #67fcc7;
            animation: animation_green 1s linear infinite;
        }
        @keyframes animation_green {
            0% {
                fill: rgb(66 219 113 / 100%);
            }
            50% {
                fill: rgb(66 219 113 / 30%);
            }
            100% {
                fill: rgb(66 219 113 / 100%);
            }
        }
        @keyframes animation_red {
            0% {
                fill: rgb(219 66 66 / 100%);
            }
            50% {
                fill: rgb(219 66 66 / 30%);
            }
            100% {
                fill: rgb(219 66 66 / 100%);
            }
        }
        .tree-state-list {
            padding: 0;
            margin: 0;
            width: 100%;
        }
        .tree-state-list li {
            padding: 0.2rem 0;
            margin: 0;
            width: 100%;
            display: grid;
            grid-template-columns: 2fr 1fr 0.5fr;
            grid-gap: 0.5rem;
            border-bottom: 1px solid #0c449e;
        }
        .tree-path {
            font-weight: normal;
            grid-column: 1 / 4 span;
        }
        .tree-numeric-path {

        }
        .tree-value {
            font-weight: bold;
            color: #0bbc0b;
        }
        .tree-option {
            cursor: pointer;
            text-decoration: none;
            padding: 0 0.3rem;
            background: white;
            color: #000000;
            display: block;
            text-align: center;
            border-radius: 2px;
            user-select: none;
        }
        .tree-option:hover {
            color: #000000;
            background-color: #4a8fff;
            text-decoration: none;
        }
        .tree-option.non-writable {
            cursor: not-allowed;
            text-decoration: line-through;
            background: #3781f9;
        }
        .tree-option.state-on {
            background: #30ce29 !important;
            color: black;
            border-color: #4CAF50 !important;
        }
        .tree-option.state-on:hover {
            background: #58e252 !important;
            color: black;
            border-color: #4CAF50 !important;
        }
        .tree-state-matrix {
            padding: 0;
            margin: 0;
            width: 100%;
            display: grid;
            grid-template-columns: 2fr 1fr 1fr;
            gap: 0.2em;
        }
        .tree-state-matrix div {
            padding: 0;
            margin: 0;
            display: grid;
            justify-content: center;
            align-content: center;
        }
        .tree-state-matrix .matrix-signal {
            justify-self: center;
            width: 15px;
            height: 15px;
            text-align: center;
            vertical-align: middle;
            justify-content: center;
            border: 1px solid #dedede;
            border-radius: 50%;
            background: #f1f1f1;
        }
        .tree-state-matrix .matrix-label--source {
            text-align: center;
            justify-content: center;
            min-height: 1.5em;
        }
        .tree-state-matrix .matrix-label--target {
            text-align: left;
            justify-content: left;
            min-height: 1.5em;
        }
        .matrix-title {
            font-weight: 400;
            font-size: 1.6em;
            padding: 5px 0 !important;
            text-align: left;
            justify-content: left !important;
        }
        .matrix-signal--connected {
            background: #30ce29 !important;
            color: black;
            border-color: #4CAF50 !important;
            animation: splash 1s normal forwards ease-in-out;
        }
        .matrix-signal--connected.source_0 {
            border: 1px solid #969e95 !important;
            color: black;
            background: #a9bdaa !important;
            animation: splash 1s normal forwards ease-in-out;
        }
        @keyframes splash {
            from {
                opacity: 0;
                transform: scale(0, 0);
            }
            50% {
                opacity: 1;
                transform: scale(1.1, 1.1);
            }
            to {
                transform: scale(1, 1);
            }
        }
        .navigation--levelcontrol {
            display: block;
            position: relative;
            width: 70px;
            z-index: 15;
            background: #b1d6d6;
            height: 400px;
            flex: 1 1 auto;
            box-shadow: 1px 1px 10px -6px #cccccc;
        }
        .drag--box {
            position: absolute;
            background: #f5f5f5;
            top: 30px;
            bottom: 30px;
            left: 0;
            right: 0;
        }
        .drag--handle {
            text-align: center;
            display: flex;
            align-items: center;
            justify-content: center;
            margin: 0;
            padding: 0;
            height: 60px;
            width: 100%;
            background: #3690ad;
            color: #ffffff;
            position: absolute;
            bottom: 0;
            left: 0;
            right: 0;
            transform: translateY(30px);
            cursor: pointer;
        }
        .drag--handle--moving {
            background: #75b5b5;
            color: #ffffff;
        }
        svg {
            width: 100%;
            height: 100%;
            fill: #e8e8e8;
        }
        svg:hover, svg:active {
            fill: #b1b1b1;
        }
    </style>
</head>
<body>
<div class="container">
    <div class="conf-container">
        <h1>Larkspur</h1>
        <h3>Socket status "<span id="socketStatus"></span>"</h3>
    </div>
    <div class="conf-container">
        <button class="tree-option"
            data-id="1.4.1.4.30.1"
            data-event="click:1.4.1.4.30.1"
            data-text="deactivate|activate">On#Off</button>

        <button class="tree-option"
            data-id="1.4.1.4.30.1"
            data-event="click:1.4.1.4.30.1"
            data-text="on|off"
            data-style="state-on">toggle</button>

        <h3>Data-event</h3>
        <input type="range" min="-200" max="0" data-event="input:1.4.1.8.8.1" />

        <h3>Data-id <span data-id="1.4.1.8.8.1"></span></h3>
        <input type="range" min="-200" max="0" data-id="1.4.1.8.8.1" />

        <h3>Different Data-id and Data-event</h3>
        <input type="range" min="-200" max="0"
            data-id="1.4.1.8.8.1"
            data-event="input:1.4.1.8.7.1" />

        <h3>Same Data-id and Data-event</h3>
        <input type="range" min="-200" max="0"
            data-id="1.4.1.8.8.1"
            data-event="input:1.4.1.8.8.1" />

        <div class="navigation--levelcontrol">
            <div class="drag--box" id="level-container">
                <div class="drag--handle" id="level-handle"></div>
            </div>
        </div>
    </div>

    <div class="conf-container">
        <div class="matrix-title">Tree</div>
        <div class="unit">
            <div class="row">
                <ul id="treeInitialList" class="tree-state-list"></ul>
            </div>
        </div>
    </div>

    <div class="conf-container">
        <div class="unit">
            <div class="row">
                <div id="matrixInitialTable">

                </div>
            </div>
        </div>
    </div>
</div>

<script src="https://cdn.jsdelivr.net/npm/@microsoft/signalr@3.1.3/dist/browser/signalr.min.js"></script>

<script>

</script>

<script type="text/javascript">
    "use strict";
    /*!
     * @copyright Copyright (c) 2020 Roger Sandholm
     */

    const EMBER_NODE_TYPES = {
        STRING: "string",
        NUMBER: "number",
        BOOLEAN: "boolean",
        UNKNOWN: "unknown"
    }

    class EmberTree {
        constructor() {
            this.treeRoot = {};
            this.nodes = {};
            this.matrices = {};
            this.onInitiated = () => {
                console.log(`Initiation callback has not been defined`);
            };
        }

        /**
         * setup subscribers for initiated event
         */
        setup(callback) {
            this.onInitiated = callback;
        }

        GetNode(path) {
            if (!path) {
                throw `No defined path to get`;
            }
            let id = this.treeIdFromStringPath(path);
            if (this.nodes.hasOwnProperty(id)) {
                return this.nodes[id];
            } else {
                throw `Could not get provided node path: ${path}`;
            }
        }

        SetNodeChanging(path, guid) {
            try {
                this.GetNode(path).ElementIsBeingModified(guid);
            } catch(error) {
                console.error("Could not set modifying because:", error);
            }
        }

        addNode(path, numericPath, value, isWritable) {
            try {
                if (this.nodes.hasOwnProperty(numericPath)) {
                    this.nodes[numericPath].Update(value);
                } else {
                    this.nodes[numericPath] = new EmberElement(path, numericPath, value, isWritable);
                }
            } catch(error) {
                console.error(error);
            }

            // Add new construction
            let pathArr = path.split("/");
            try {
                this.addNodeElement(this.nodes[numericPath], pathArr, this.treeRoot);
            } catch(error) {
                console.error(error);
            }
        }

        addNodeElement(emberElement, pathArr, currentPointer) {
            //console.log(pathArr)
            if (pathArr.length == 0) {
                return true;
            }
            if (currentPointer.hasOwnProperty(pathArr[0])) {
                // Have the position been added to the tree?
                // If yes then just point to that
                return this.addNodeElement(emberElement, pathArr.slice(1), currentPointer[pathArr[0]])
            } else {
                // There is no node at this position, so add a new node
                if (pathArr.length == 1) {
                    currentPointer[pathArr[0]] = emberElement;
                } else {
                    currentPointer[pathArr[0]] = new EmberNode(pathArr[0]);
                }
                return this.addNodeElement(emberElement, pathArr.slice(1), currentPointer[pathArr[0]])
            }
        }

        // GetNodeChildren(pathArr) {
        //     this.findNodeChildren(pathArr, this.treeRoot)
        // }

        // findNodeChildren(pathArr, currentPointer) {
        //     if (pathArr.length == 0) {
        //         return currentPointer;
        //     }
        //     if (currentPointer.hasOwnProperty(pathArr[0])) {
        //         // Have the position been added to the tree?
        //         // If yes then just point to that
        //         return this.findNodeChildren(emberElement, pathArr.pop(), currentPointer[pathArr[0]])
        //     } else {
        //         // There is no node at this position, so add a new node
        //         return false;
        //     }
        // }

        treeIdFromStringPath(path) {
            if (!path) {
                return "no_path_available";
            }
            return path.split("/").join("").toLowerCase().replace(" ", "_");
        }

        // treeIdParentFromStringPath(path, parentCount) {
        //     let arr = path.split("/");
        //     parentCount = parentCount || 1;
        //     arr.splice(-parentCount);
        //     return arr.join("").toLowerCase().replace(" ", "_");
        // }

        // Tree
        buildTreeView(tree) {
            try {
                let frag = document.createDocumentFragment();
                let arr = Object.entries(tree);
                for (let i = 0; i < arr.length; i++) {
                    // Build an object for each node
                    this.addNode(arr[i][0], arr[i][1].numericPath, arr[i][1].value, arr[i][1].isWritable);

                    // Add DOM objects
                    try {
                        let data = this.GetNode(arr[i][1].numericPath);

                        let li = document.createElement("LI");

                        // Add path information
                        let dv1 = document.createElement("DIV");
                        dv1.classList.add("tree-path");
                        dv1.textContent = data.path;
                        li.appendChild(dv1);

                        // Add numeric path
                        let dvp = document.createElement("DIV");
                        dvp.classList.add("tree-numeric-path");
                        dvp.textContent = data.numericPath;
                        li.appendChild(dvp);

                        // Add actual values
                        let dv2 = document.createElement("DIV");
                        dv2.classList.add("tree-value");
                        dv2.textContent = data.value;
                        dv2.setAttribute("data-key", new DataKey(data.numericPath, "text"));
                        dv2.setAttribute("data-id", data.numericPath);
                        li.appendChild(dv2);

                        // Add edit button
                        if (data.isWritable) {
                            let dvo = document.createElement("DIV");
                            dvo.classList.add("tree-options");

                            if (typeof (data.value) === "string") {
                                let dvlink = document.createElement("A");
                                dvlink.classList.add("tree-option");
                                dvlink.textContent = "change";
                                let ofn = `emberChangeString(this,'${data.path}','${data.value}','${data.numericPath}')`;
                                dvlink.setAttribute("onclick", ofn);
                                dvo.append(dvlink);
                            }
                            if (typeof (data.value) === "number") {
                                let dvlink = document.createElement("A");
                                dvlink.classList.add("tree-option");
                                dvlink.textContent = "change";
                                let ofn = `emberChangeNumber(this,'${data.value}','${data.numericPath}')`;
                                dvlink.setAttribute("onclick", ofn);
                                dvo.append(dvlink);
                            }
                            if (typeof (data.value) === "boolean") {
                                let link = document.createElement("A");
                                link.classList.add("tree-option");
                                link.setAttribute("data-key", new DataKey(data.numericPath, "class", "state-on"));
                                link.setAttribute("data-id", data.numericPath);
                                link.textContent = "toggle";

                                if (data.value) {
                                    link.classList.add("state-on");
                                }

                                let ofnfalse = `emberToggleBoolean(this,'${data.numericPath}')`;
                                link.setAttribute("onclick", ofnfalse);
                                dvo.append(link);
                            }
                            li.appendChild(dvo);
                        } else {
                            let dvo = document.createElement("DIV");
                            dvo.classList.add("tree-options");
                            let dvlink = document.createElement("SPAN");
                            dvlink.classList.add("tree-option");
                            dvlink.classList.add("non-writable");
                            dvlink.textContent = "change";
                            dvo.append(dvlink);
                            li.appendChild(dvo);
                        }

                        li.id = "id_row_" + this.treeIdFromStringPath(data.path);
                        frag.prepend(li);
                    } catch(error) {
                        console.error(error);
                    }
                }

                // Setup UI-library callbacks
                this.onInitiated();
                return frag;
            } catch(err) {
                console.warn(err);
                return document.createDocumentFragment();
            }
        }

        updateInitialElements() {
            let elements = Object.entries(this.nodes);
            if (elements.length != 0) {
                elements.forEach((key, value) => {
                    this.updateDom(key[0], key[1].value);
                });
            } else {
                console.warn("No elements to update");
            }
        }

        updateNodeElement(path, value) {
            if (this.nodes.hasOwnProperty(path)) {
                this.nodes[path].Update(value);
                this.updateDom(path, value);
                return true;
            } else {
                return false;
            }
        }

        updateDom(path, value) {
            let selectedElements = document.querySelectorAll("[data-key]");
            selectedElements.forEach(function(item) {
                let obj = JSON.parse(item.dataset.key);
                // console.log(obj.id, "IIIIS", path);
                if (obj.id === path) {
                    window.requestAnimationFrame(function() {
                        switch(obj.type) {
                            case "class":
                                if (value) {
                                    if (!item.classList.contains(obj.value)) {
                                        item.classList.add(obj.value);
                                    }
                                } else {
                                    item.classList.remove(obj.value);
                                }
                                break;
                            default:
                                // Actually update DOM node
                                item.innerHTML = value;
                                break;
                        }
                    });
                }
            });
        }

        // Matrices
        buildMatrixView(path, matrix) {
            try {
                let frag = document.createDocumentFragment();
                let box = document.createElement("DIV");
                box.classList.add("tree-state-matrix");
                box.id = emberTree.treeIdFromStringPath(path);

                if (matrix.hasOwnProperty("sources") && matrix.hasOwnProperty("targets")) {
                    // Add matrix title label
                    let lbl = document.createElement("DIV");
                    lbl.classList.add("matrix-title");
                    lbl.style.gridColumn = `1 / span ${matrix.sources.length + 1}`;
                    lbl.textContent = matrix.name;
                    box.append(lbl);

                    // Add top left corner
                    let div = document.createElement("DIV");
                    div.classList.add("matrix-origo");
                    box.append(div);

                    // Add matrix
                    let sources = matrix.sources;
                    for (let i = 0; i < sources.length; i++) {
                        // Source label
                        let div = document.createElement("DIV");
                        div.textContent = sources[i].name;
                        div.classList.add("matrix-label--source");
                        div.setAttribute("data-key", new DataKey(this.treeIdFromStringPath(sources[i].labelPath)));
                        box.append(div);
                    }

                    let targets = matrix.targets;
                    for (let i = 0; i < targets.length; i++) {
                        // Target label
                        let div = document.createElement("DIV");
                        div.textContent = targets[i].name;
                        div.classList.add("matrix-label--target");
                        div.setAttribute("data-key", new DataKey(this.treeIdFromStringPath(targets[i].labelPath)));
                        box.append(div);

                        // Signals
                        for (let y = 0; y < sources.length; y++) {
                            let signal = document.createElement("DIV");
                            signal.classList.add("matrix-signal");
                            signal.classList.add("source_" + y);
                            signal.classList.add("matrix-signal_" + targets[i].index + "_" + this.treeIdFromStringPath(path));
                            signal.id = "id_signal_" + sources[y].index + "_" + targets[i].index + "_" + this.treeIdFromStringPath(path);

                            // Actually connect
                            if (targets[i].connectedSources.length !== 0) {
                                targets[i].connectedSources.forEach((item) => {
                                    if (item === sources[y].index) {
                                        signal.classList.add("matrix-signal--connected");
                                    }
                                });
                            }

                            box.append(signal);
                        }
                    }
                }

                box.style.gridTemplateColumns = `2fr repeat(${matrix.sources.length}, 1fr)`;
                frag.append(box);
                return frag;
            } catch(err) {
                console.warn(err);
                return document.createDocumentFragment();
            }
        }

        updateMatrixSignal(path, target) {
            // Remove all connected sources from target
            let targetBoxes = document.querySelectorAll(".matrix-signal_" + target.index + "_" + this.treeIdFromStringPath(path));
            targetBoxes.forEach(function(item) {
                item.classList.remove("matrix-signal--connected");
            });

            // Connect target with source
            for (let i = 0; i < target.connectedSources.length; i++) {
                document.getElementById("id_signal_" + target.connectedSources[i] + "_" + target.index + "_" + this.treeIdFromStringPath(path)).classList.add("matrix-signal--connected");
            }
        }
    }

    class EmberNode {
        constructor(nodeName) {
            this.nodeName = nodeName;
        }
    }

    class EmberElement {
        constructor(path, numericPath, value, isWritable) {
            this.path = path;
            this.numericPath = numericPath;
            this.readablePath = path.split("/").join("").toLowerCase().replace(" ", "_");
            this.value = value;

            this.valueTypeToDefinition(value);
            this.isWritable = isWritable;

            this.$elements = Array.from(document.querySelectorAll(`[data-id='${this.numericPath}']`))
                .map((element) => new UIElement(element));

            this.Update(value);
        }

        ElementIsBeingModified(guid) {
            this.$elements.forEach((element) => {
                if (element.element.guid === guid) {
                    element.UserIsChanging();
                }
            });
        }

        Update(value) {
            this.value = value;

            if (this.$elements.length > 0) {
                this.$elements.forEach((item) => {
                    switch(this.type) {
                        case EMBER_NODE_TYPES.NUMBER:
                            item.SetValue(this.value);
                            break;

                        case EMBER_NODE_TYPES.BOOLEAN:
                            item.SetClass(this.value);
                            item.SetText(this.value);
                            break;

                        case EMBER_NODE_TYPES.STRING:
                            item.SetValue(this.value);
                            break;

                        default:
                            console.warn(`Unknown EmBER+ type ${this.type}, will not update DOM`);
                            break;
                    };
                });
            }
        }

        valueTypeToDefinition(type) {
            switch(typeof(type)) {
                case EMBER_NODE_TYPES.STRING:
                    this.type = EMBER_NODE_TYPES.STRING;
                    break;
                case EMBER_NODE_TYPES.NUMBER:
                    this.type = EMBER_NODE_TYPES.NUMBER;
                    break;
                case EMBER_NODE_TYPES.BOOLEAN:
                    this.type = EMBER_NODE_TYPES.BOOLEAN;
                    break;
                default:
                    this.type = EMBER_NODE_TYPES.UNKNOWN;
                    break;
            }
        }
    }

    class UserInterface {
        constructor() {

        }

        initiateListeners() {
            let $lsn = document.querySelectorAll("[data-event]");
            $lsn.forEach(function(elm) {
                let item = elm.dataset.event.split(":") || ["click", elm.dataset.event];

                console.log("Init listener for:", item);
                console.log(emberTree.GetNode(item[1]));

                // Generate unique element identification
                elm.guid = createGuid();

                switch(item[0]) {
                    case "click":
                        elm.addEventListener(item[0], (event) => {
                            console.log("event click", event);
                            emberToggleBoolean(event.target, item[1]);
                        });
                        break;

                    case "input":
                        elm.addEventListener(item[0], (event) => {
                            console.log("event input", event);

                            // Check if data-id is the same binding as event
                            // to determine what is actually being modified
                            // if (event.target.dataset.id && event.target.dataset.id !== item[1]) {
                            //     console.log(`Not same listener id ${item[1]} as data id ${event.target.dataset.id}`);
                            //     emberTree.SetNodeChanging(event.target.dataset.id, elm.guid);
                            // }

                            // Set actual value and say its changing
                            emberTree.SetNodeChanging(item[1], elm.guid);
                            emberChangeInt(event.target.value, item[1]);
                        });
                        break;
                }
            });

            emberTree.updateInitialElements();
        }
    }

    function createGuid() {
        function randNum() {
            return Math.floor((1 + Math.random()) * 0x10000).toString(16).substring(1);
        }
        return randNum() + randNum() + '-' + randNum() + '-' + randNum() + '-' + randNum() + '-' + randNum() + randNum() + randNum();
    }

    class UIElement {
        constructor(element) {
            this.element = element;
            this.elementType = element.nodeName.toLowerCase();
            this.guid = element.guid;

            this.isChanging = false;
            this.changingTimeout = null;

            // Set up text data
            if (this.element.dataset.text) {
                let text = this.element.dataset.text.split("|");
                if (text.length == 2) {
                    this.elementText = text;
                } else if(text.length == 1) {
                    text.push(text[0]);
                    this.elementText = text;
                }
            }

            // Set up style data
            if (this.element.dataset.style) {
                this.elementStyle = this.element.dataset.style;
            } else {
                this.elementStyle = "state-on";
            }

            // Set up listeners for change detection
            // also make sure the listener is here..
            // if (this.element.dataset.event) {
            //     console.log("HAS EVENTS", this.element.dataset.event, this.element)
            // }
        }

        UserIsChanging() {
            clearTimeout(this.changingTimeout);
            this.isChanging = true;
            this.changingTimeout = setTimeout(() => {
                this.isChanging = false;
                this.drawValue();
            }, 200);
        }

        SetValue(value) {
            this.value = value;
            if (!this.isChanging) {
                this.drawValue();
            }
        }

        drawValue() {
            window.requestAnimationFrame(() => {
                switch(this.elementType) {
                    case "input":
                        this.element.value = this.value;
                        break;
                    default:
                        this.element.innerHTML = this.value;
                        break;
                }
            });
        }

        SetText(value) {
            if (this.elementText) {
                if (value) {
                    this.element.innerHTML = this.elementText[0];
                } else {
                    this.element.innerHTML = this.elementText[1];
                }
            }
        }

        SetClass(value) {
            if (value) {
                this.element.classList.add(this.elementStyle);
            } else {
                this.element.classList.remove(this.elementStyle);
            }
        }
    }

    function DataKey(id, type, value) {
        this.id = id || "#";
        this.type = type || "#";
        this.value = value || "#";
    }

    DataKey.prototype.toString = function dogToString() {
        return JSON.stringify(this);
    }

    var ui = new UserInterface();
    var emberTree = new EmberTree();
    emberTree.setup(() => {
        ui.initiateListeners();
    });

    var connection = new signalR.HubConnectionBuilder()
        .withUrl("/larkspurHub")
        .withAutomaticReconnect()
        .build();

    setSocketConnectionFeedback("Disconnected");

    connection.on("InitialEmberTree", (tree) => {
        console.log(`Event 'InitialEmberTree':`, tree);
        let $doc = document.getElementById("treeInitialList") || document.createElement("DIV");
        $doc.innerHTML = "";
        let frag = emberTree.buildTreeView(tree);
        $doc.append(frag);
    });

    connection.on("ChangesInEmberTree", (path, data) => {
        console.log(`Event 'ChangesInEmberTree', path:${JSON.stringify(path)}`);
        console.table(data);
        emberTree.updateNodeElement(data.numericPath, data.value);
    });

    connection.on("InitialEmberTreeMatrix", (matrices) => {
        console.log(`Event 'InitialEmberTreeMatrix': ${JSON.stringify(matrices)}`);
        let $doc = document.getElementById("matrixInitialTable") || document.createElement("DIV");
        $doc.innerHTML = "";
        let arr = Object.entries(matrices).sort();
        for (let i = 0; i < arr.length; i++) {
            let frag = emberTree.buildMatrixView(arr[i][0], arr[i][1]);
            $doc.append(frag);
        }
    });

    connection.on("ChangesInEmberTreeMatrix", (path, target) => {
        console.log(`Event 'ChangesInEmberTree', path:${JSON.stringify(path)}, target:${JSON.stringify(target)}`);
        emberTree.updateMatrixSignal(path, target);
    });

    connection.start()
        .then(function () {
            setSocketConnectionFeedback(connection.connectionState);
            commandRequestInitialState();
        })
        .catch(function (err) {
            setSocketConnectionFeedback("Error " + err.toString());
            return console.error(err.toString());
        });

    connection.onclose(function() {
        console.log("connection onclose");
        setSocketConnectionFeedback(connection.connectionState);
    });

    connection.onreconnecting(function(error) {
        console.log("connection onreconnecting", error);
        setSocketConnectionFeedback(connection.connectionState);
    });

    connection.onreconnected(function() {
        console.log("connection onreconnected");
        setSocketConnectionFeedback(connection.connectionState);
        commandRequestInitialState();
    });

    function commandRequestInitialState() {
        if (connection) {
            connection.invoke("RequestInitialState").catch((err) => {
                return console.error("Could not request initial state", err);
            });
        }
    }

    function setSocketConnectionFeedback(message) {
        document.getElementById("socketStatus").textContent = message;
    }

    function emberChangeString(element, path, value, numericPath) {
        let change = window.prompt(`Change string`, value);
        if (change !== null) {
            connection.send("ChangeEmberStringParameter", numericPath, change).catch((err) => {
                return console.error("Could not send change", err);
            });
        }
    }

    function emberChangeNumber(element, value, numericPath) {
        let change = window.prompt(`Change number`, value);
        if (change !== null) {
            connection.send("ChangeEmberNumberParameter", numericPath, parseInt(change)).catch((err) => {
                return console.error("Could not send change", err);
            });
        }
    }

    function emberChangeInt(value, numericPath) {
        connection.send("ChangeEmberNumberParameter", numericPath, parseInt(value)).catch((err) => {
            return console.error("Could not send change", err);
        });
    }

    function emberToggleBoolean(element, numericPath) {
        try {
            let item = emberTree.GetNode(numericPath);
            console.log(item)
            let state = !item.value; // inverse
            connection.send("ChangeEmberBooleanParameter", numericPath, state ).catch((err) => {
                return console.error("Could not send change", err);
            });
        } catch(error) {
            console.error("EmberToggleBoolean: ", error);
        }
    }

    function emberChangeBool(value, numericPath) {
        if (element.dataset.id !== undefined) {
            try {
                let item = emberTree.GetNode(element.dataset.id);
                console.log(item)
                let state = !item.value; // inverse
                connection.send("ChangeEmberBooleanParameter", numericPath, state).catch((err) => {
                    return console.error("Could not send change", err);
                });
            } catch(error) {
                console.error("EmberToggleBoolean: ", error);
            }
        }
    }

    class OUIFader {
        constructor() {
            console.log("constructor me");
            this.domContainerId = "level-container"
            this.domHandleId = "level-handle";
            this.domHandleMoving = false;
            this.monitorLevel = 100;

            this.mouseClickHandlerMove = null;
            this.mouseClickHandlerUp = null;
            this.mouseClickHandlerScroll = null;

            this.incomingLevelValue = new Debouncer(200, () => {
                this.sliderYPosition = this.monitorLevel;
                this.setHandleOnPath();
            });

            this.sliderYPosition = this.monitorLevel;
            this.setHandleOnPath();
            this.setUpDomListeners();
        }

        levelControlChanged(data) {
            this.monitorLevel = data;

            if (!this.domHandleMoving) {
                this.incomingLevelValue.trigger();
            }
        }

        setUpDomListeners() {
            console.log("setupdomlisteners");
            document.getElementById(this.domHandleId).addEventListener("mousedown", this.goMouseDown.bind(this), false);
        }

        goMouseDown(e) {
            console.log("goMouseDown", e, this.domHandleId);
            document.getElementById(this.domHandleId).classList.add("drag--handle--moving");

            // Remove previous existing listeners to avoid collision
            this.goRemoveEventListeners();
            this.domHandleMoving = true;

            // Set up new event listeners
            this.mouseClickHandlerUp = this.goMouseUp.bind(this);
            window.addEventListener("mouseup", this.mouseClickHandlerUp, true);

            this.mouseClickHandlerMove = this.divMove.bind(this);
            window.addEventListener("mousemove", this.mouseClickHandlerMove, true);
        }

        goMouseUp(e) {
            console.log("goMouseUp", e, this.domHandleId);
            if (this.domHandleId !== undefined && this.domHandleId !== null) {
                document.getElementById(this.domHandleId).classList.remove("drag--handle--moving");
            }
            this.goRemoveEventListeners();
            this.incomingLevelValue.trigger();
        }

        goRemoveEventListeners() {
            console.log("removeeventlisteners");
            window.removeEventListener("mousemove", this.mouseClickHandlerMove, true);
            window.removeEventListener("mouseup", this.mouseClickHandlerUp, true);
            this.domHandleMoving = false;
        }

        divMove(e) {
            console.log("divmove");
            let positionY = e.clientY;
            let svgContainer = document.getElementById(this.domContainerId).getBoundingClientRect();
            this.sliderYPosition = 100 - ((positionY - svgContainer.top) * (100 / svgContainer.height ));
            this.sliderYPosition = positionY >= svgContainer.bottom ? 0 : this.sliderYPosition;
            this.sliderYPosition = positionY <= svgContainer.top ? 100 : this.sliderYPosition;
            this.setHandleOnPath();
            this.setFaderLevel();
        }

        setFaderLevel() {
            let level = this.sliderYPosition / 100;
            console.log(this.monitorLevel, level);
            // this.controlEngineHub.invokeMessage(
            //     ControlEngineCommands.Monitor_SetLevel,
            //     this.controlEngineAppModelId,
            //     this.monitorLevel().identifier,
            //     level,
            //     );
        }

        setHandleOnPath() {
            if (this.sliderYPosition === 0) {
                document.getElementById(this.domHandleId).textContent = "MUTE";
            } else {
                document.getElementById(this.domHandleId).textContent = Math.round(this.sliderYPosition).toString() + "%";
            }
            document.getElementById(this.domHandleId).style.bottom = this.sliderYPosition.toString() + "%";
        }

    }

    class Debouncer {
        constructor(updateInterval, callbackUpdate) {
            this.updateInterval = updateInterval;
            this.update = callbackUpdate;

            this.timeoutHandle = null;
        }

        trigger(executeNow = false) {
            if (executeNow) {
                this.clear();
                this.execute();
            } else {
                this.startTimeout();
            }
        }

        clear() {
            clearTimeout(this.timeoutHandle);
        }

        startTimeout() {
            this.clear();
            this.timeoutHandle = setTimeout(() => {
                this.execute();
                this.timeoutHandle = null;
                console.log("Timeout runned");
            }, this.updateInterval);
        }

        execute() {
            this.update();
        }
    }

try {
    const fader1 = new OUIFader();
} catch(error) {
    console.error(error)
}

</script>
</body>
</html>