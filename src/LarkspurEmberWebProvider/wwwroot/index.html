<!DOCTYPE html>
<html lang="en" xmlns="http://www.w3.org/1999/xhtml">
<head>
    <meta charset="utf-8">
    <meta name="viewport" content="initial-scale=1.0, maximum-scale=1.0, width=device-width, user-scalable=no">
    <title>Larkspur</title>
    <style type="text/css">
        @import url('https://fonts.googleapis.com/css2?family=Lexend+Deca&display=swap');
        body, html {
            margin: 0;
            padding: 0;
            font-family: 'Lexend Deca', Arial, Helvetica, sans-serif !important;
            -webkit-font-smoothing: subpixel-antialiased;
            -ms-text-size-adjust: 100%;
            -webkit-text-size-adjust: 100%;
            background: #3769bb;
            background: linear-gradient(to bottom, #379fbb 0%, #3769bb 100%);
            color: #e7f5ff;
        }
        .container {
            padding: 2rem 1rem 300px 1rem;
            margin: 0 auto 0 auto;
            max-width: 800px;
            position: relative;
            overflow: hidden;
        }
        .conf-container {
            padding: 0.8rem 2rem;
            line-height: 1.8rem;
        }
        code {
            font-family: 'Lexend Deca', Arial, Helvetica, sans-serif !important;
            background: #56c1de;
            color: #3769bb;
            padding: 0 0.3rem;
        }
        a {
            color: #4263e6;
            text-decoration: underline;
            cursor:pointer;
        }
        a:hover {
            color: #9a42ce;
            text-decoration: underline;
        }
        h1 {
            font-size: 4rem;
            text-shadow: 1px 1px 2px #3386ae;
        }
        h2 {
            font-size: 1.6rem;
            text-shadow: 1px 1px 2px #3386ae;
        }
        .small {
            font-size: 12px;
        }
        .unit {
            margin-top: 15px;
        }
        button {
            background: #5f5f5f;
            border: 1px solid #313131;
            color: #fff;
            padding: 0 1em;
            min-height: 35px;
            font-size: 1em;
            cursor: pointer;
            -webkit-transition: all 0.2s;
            -moz-transition: all 0.2s;
            transition: all 0.2s;
            border-radius: 2px;
        }
        button:hover {
            background: #333333;
        }
        .larkspur-logo {
            width: 7rem;
            height: 7rem;
            position: absolute;
            top: 1.2rem;
            left: 20.6rem;
            opacity: 0.8;
        }
        input, select {
            border: 0;
            padding: 0 0 0 10px;
            background: #fff;
            border: 1px solid #4c4c4c;
            font-size: 1em;
            border-radius: 0;
            outline: 0;
            -webkit-appearance: none;
            height: 35px;
            box-sizing: border-box;
            border-radius: 2px;
            min-width: 35%;
        }
        input[type="range"] {
            -webkit-appearance: none;
            height: 10px;
            border-radius: 5px;
            background: #7530a0;
            background: rgba(117, 48, 160, 0.5);
            outline: none;
            padding: 0;
            margin: 1rem 0;
            width: 100%;
        }
        input[type="range"]::-webkit-slider-thumb {
            -webkit-appearance: none;
                    appearance: none;
            width: 40px;
            height: 40px;
            border-radius: 50%;
            background: #2c3e50;
            cursor: pointer;
            -webkit-transition: background .15s ease-in-out;
            transition: background .15s ease-in-out;
        }
        input[type="range"]::-webkit-slider-thumb:hover {
            background: #1abc9c;
        }
        input[type="range"]:active::-webkit-slider-thumb {
            background: #1abc9c;
        }
        input[type="range"]::-moz-range-thumb {
            width: 40px;
            height: 40px;
            border: 0;
            border-radius: 50%;
            background: #2c3e50;
            cursor: pointer;
            -moz-transition: background .15s ease-in-out;
            transition: background .15s ease-in-out;
        }
        input[type="range"]::-moz-range-thumb:hover {
            background: #1abc9c;
        }
        input[type="range"]:active::-moz-range-thumb {
            background: #1abc9c;
        }
        input[type="range"]:focus::-webkit-slider-thumb {
            box-shadow: 0 0 0 3px #fff, 0 0 0 6px #1abc9c;
        }
        select {
            padding: 0 30px 0 10px;
            background-image: linear-gradient(45deg, transparent 50%, #000000 50%), linear-gradient(135deg, black 50%, transparent 50%), linear-gradient(to right, white, white);
            background-position: calc(100% - 16px) calc(0.8em + 2px), calc(100% - 11px) calc(0.8em + 2px), 100% 0;
            background-size: 5px 5px, 5px 5px, 2.5em 2.5em;
            background-repeat: no-repeat;
        }
        .tree-state-list {
            padding: 0;
            margin: 0;
            width: 100%;
            border-collapse: collapse;
        }
        .tree-state-list tr td {
            padding: 0.2rem 0.1rem;
            margin: 0;
            width: 100%;
            border-bottom: 1px solid #0c449e;
        }
        .tree-path {
            font-weight: normal;
            font-size: 0.8rem;
            color: #1b2a78;
        }
        .tree-path span:nth-last-child(-n+2) {
            font-weight: bold;
            color: #b2b2ff;
        }
        .tree-numeric-path {

        }
        .tree-node-name {
            color: #1c1378;
        }
        .tree-value {
            font-weight: bold;
            min-width: 10rem;
            color: #1ecc1e;
        }
        .tree-option {
            cursor: pointer;
            text-decoration: none;
            padding: 0 0.3rem;
            background: white;
            color: #000000;
            display: block;
            text-align: center;
            border-radius: 2px;
            user-select: none;
        }
        .tree-option:hover {
            color: #000000;
            background-color: #4a8fff;
            text-decoration: none;
        }
        .tree-option.non-writable {
            cursor: not-allowed;
            text-decoration: line-through;
            background: #3781f9;
        }
        .tree-option.state-on {
            background: #30ce29 !important;
            color: black;
            border-color: #4CAF50 !important;
        }
        .tree-option.state-on:hover {
            background: #58e252 !important;
            color: black;
            border-color: #4CAF50 !important;
        }
        .tree-state-matrix {
            padding: 0;
            margin: 0;
            width: 100%;
            display: grid;
            grid-template-columns: 2fr 1fr 1fr;
            gap: 0.2em;
        }
        .tree-state-matrix div {
            padding: 0;
            margin: 0;
            display: grid;
            justify-content: center;
            align-content: center;
        }
        .tree-state-matrix .matrix-signal {
            justify-self: center;
            width: 15px;
            height: 15px;
            text-align: center;
            vertical-align: middle;
            justify-content: center;
            border: 1px solid #dedede;
            border-radius: 50%;
            background: #f1f1f1;
        }
        .tree-state-matrix .matrix-label--source {
            text-align: center;
            justify-content: center;
            min-height: 1.5em;
        }
        .tree-state-matrix .matrix-label--target {
            text-align: left;
            justify-content: left;
            min-height: 1.5em;
        }
        .matrix-title {
            font-weight: 400;
            font-size: 1.6rem;
            padding: 5px 0 !important;
            text-align: left;
            justify-content: left !important;
        }
        .matrix-signal--connected {
            background: #30ce29 !important;
            color: black;
            border-color: #4CAF50 !important;
            animation: splash 1s normal forwards ease-in-out;
        }
        .matrix-signal--connected.source_0 {
            border: 1px solid #969e95 !important;
            color: black;
            background: #a9bdaa !important;
            animation: splash 1s normal forwards ease-in-out;
        }
        @keyframes splash {
            from {
                opacity: 0;
                transform: scale(0, 0);
            }
            50% {
                opacity: 1;
                transform: scale(1.1, 1.1);
            }
            to {
                transform: scale(1, 1);
            }
        }
        .navigation--levelcontrol {
            display: block;
            position: relative;
            width: 70px;
            z-index: 15;
            background: #b1d6d6;
            height: 400px;
            flex: 1 1 auto;
            box-shadow: 1px 1px 10px -6px #cccccc;
        }
        .drag--box {
            position: absolute;
            background: #f5f5f5;
            top: 30px;
            bottom: 30px;
            left: 0;
            right: 0;
        }
        .drag--handle {
            text-align: center;
            display: flex;
            align-items: center;
            justify-content: center;
            margin: 0;
            padding: 0;
            height: 60px;
            width: 100%;
            background: #3690ad;
            color: #ffffff;
            position: absolute;
            bottom: 0;
            left: 0;
            right: 0;
            transform: translateY(30px);
            cursor: pointer;
        }
        .drag--handle--moving {
            background: #75b5b5;
            color: #ffffff;
        }
        svg {
            width: 100%;
            height: 100%;
            fill: #e8e8e8;
        }
        svg:hover, svg:active {
            fill: #b1b1b1;
        }
        .doc-table {
            width: 100%;
        }
        .doc-table td {
            padding: 0.5rem;
            line-height: 1rem;
            overflow-wrap: anywhere;
        }
        .doc-table tr td:first-child {
            color: #0b2857;
            min-width: 140px;
            text-shadow: 1px 1px 2px #3386ae;
        }
        .doc-table .attribute {
            font-size: 1.3rem;
            font-weight: bold;
            color: #151030 !important;
        }


        /* INSERT YOUR CUSTOM CSS */

    </style>
</head>
<body>
<div class="container">
    <div class="conf-container">
        <h1>Larkspur</h1>
        <h3>Socket status "<span id="socketStatus"></span>"</h3>
        <div class="larkspur-logo">
            <svg version="1.1" xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink" x="0px" y="0px" viewBox="0 0 50 50" enable-background="new 0 0 50 50" xml:space="preserve">
                <g>
                    <g>
                        <path fill="#693091" d="M23.1,26.5c-0.8,0.2-5.5-6-5.2-11.3c0.4-6.2,6.2-13.3,7.6-13.5s9.6,8,7.4,14.3C30.2,23.7,24.2,26.2,23.1,26.5z"/>
                        <path fill="#593194" d="M23.2,26.9c0.6-1.2-4-12.2-8-13.6C10.2,11.5,2.9,15.3,2.5,17c-0.4,1.7,1.6,11.4,8,12.3C15.2,29.9,22.8,27.8,23.2,26.9z"/>
                        <path fill="#813194" d="M22.9,26.1c0-1,4.9-8.6,11.9-8.9c8.5-0.4,12.7,8.5,12.7,9.1s-4.8,8.8-12.7,8.4C27.1,34.4,22.9,27.3,22.9,26.1z"/>
                        <path fill="#923288" d="M23,26.7c1.5-0.6,7.4,1,9.2,3.9C36.7,37.9,35,47,33,48.2c-1.3,0.8-11.1-2.8-12.7-12.1C19.5,31.9,22,27.1,23,26.7z"/>
                        <path fill="#493390" d="M22.8,26.8c1.1,1.1,0,13.2-3.8,15.4s-13.7,2.9-14.5,2c-0.7-1,0-10.8,4.3-13.9C14.1,26.4,21.6,25.6,22.8,26.8z"/>
                    </g>
                    <path fill="#612FA8" d="M19.5,26.7c0.2-1.1,0.6-4.3,3.3-4c2.7,0.3,4.8,3.1,4.3,5.2c-0.5,2.1-3.2,3.3-5.2,3.3C19.9,31.2,19.4,27.8,19.5,26.7z"/>
                </g>
                </svg>
        </div>
    </div>

    <div class="conf-container">
        <h2>The OUI-kit</h2>
        <p>
            I've created a very simple javascript library to interact with the EmBER+ parameters. You could implement your own if you feel comfortable with that. All interactions with the gateway is done using SignalR (websockets).
            Listen to the following events <code>InitialEmberTree | ChangesInEmberTree | InitialEmberTreeMatrix | ChangesInEmberTreeMatrix</code>. Get started by requesting the full tree with the <code>RequestInitialState</code> command.
            Use the following messages to then control the EmBER+ parameters <code>ChangeEmberStringParameter | ChangeEmberNumberParameter | ChangeEmberBooleanParameter | PulseEmberBooleanParameter</code>. The command also needs the EmBER+ parameters <code>numeric path</code> and the <code>value</code> that is requested.
        </p>
        <p>
            To get started right away, use the provided javascript library. 
            Just add the <code>data-id</code> attribute with the numeric EmBER+ path to attach the value to a HTMLElement <code>&lt;div data-id='1.2.3.4.1'&gt;&lt;/div&gt;</code>.
            To control parameters in the EmBER+ tree, just add the <code>data-event</code> with type to listen to. If it's an HTMLInputElement add <code>&lt;div data-event='input:1.2.3.4.1'&gt;&lt;/div&gt;</code>.
            For the <code>data-event</code> attribute, valid arguments is <code>input | click | pulse</code>. The pulse is toggling an EmBER+ boolean parameter.
            The <code>data-id</code> is used together with <code>data-event</code> attribute for a two way binding.
        </p>
        <table class="doc-table">
            <tr>
                <td colspan="2" class="attribute">data-id</td>
            </tr>
            <tr>
                <td>value</td><td>x.x.x.x</td>
            </tr>
            <tr>
            </tr>
                <td>description</td><td>Use the numeric path of the EmBER+ node you are interested in.</td>
            </tr>

            <tr>
                <td colspan="2" class="attribute">data-event</td>
            </tr>
            <tr>
                <td>value</td><td>input:x.x.x.x|click:x.x.x.x|pulse:x.x.x.x</td>
            </tr>
            </tr>
                <td>description</td><td>Bind the requested type of HTMLEventListener to use for setting the numeric path EmBER+ parameter. Separate the event and path with ':'.</td>
            </tr>

            <tr>
                <td colspan="2" class="attribute">data-show</td>
            </tr>
            <tr>
                <td>value</td><td>block|flex|...</td>
            </tr>
            <tr>
                <td>description</td><td>Toggle the visibility of an object with the added css property. This is based on the data-id and on boolean EmBER+ parameter.</td>
            </tr>

            <tr>
                <td colspan="2" class="attribute">data-text</td>
            </tr>
            <tr>
                <td>value</td><td>text-true|text-false</td>
            </tr>
            <tr>
                <td>description</td><td>Add a text that will be changed depending on an boolean EmBER+ parameter</td>
            </tr>

            <tr>
                <td colspan="2" class="attribute">data-style</td>
            <tr>
                <td>value</td><td>css-class-name</td>
            <tr>
                <td>description</td><td>Add the css class style that will be applied to boolean EmBER+ parameters, on true.</td>
            </tr>
        </table>
    </div>

    <div class="conf-container">
        <div class="matrix-title">Tree</div>
        <div class="unit">
            <div class="row">
                <table id="treeInitialList" class="tree-state-list"></table>
            </div>
        </div>
    </div>

    <div class="conf-container">
        <div class="unit">
            <div class="row">
                <div id="matrixInitialTable">

                </div>
            </div>
        </div>
    </div>
</div>

<script src="/signalr.js"></script>

<script type="text/javascript">
    "use strict";
    /*!
     * @copyright Copyright (c) 2020 Roger Sandholm
     */

    const EMBER_NODE_TYPES = {
        STRING: "string",
        NUMBER: "number",
        BOOLEAN: "boolean",
        UNKNOWN: "unknown"
    }

    class EmberTree {
        constructor() {
            this.treeRoot = {};
            this.nodes = {};
            this.matrices = {};
            this.onInitiated = () => {
                console.log(`Initiation callback has not been defined`);
            };
        }

        /**
         * Setup subscribers for initiated event
         */
        setup(callback) {
            this.onInitiated = callback;
        }

        GetNode(path) {
            if (!path) {
                throw `No defined path to get`;
            }
            let id = this.treeIdFromStringPath(path);
            if (this.nodes.hasOwnProperty(id)) {
                return this.nodes[id];
            } else {
                throw `Could not get provided node path: ${path}`;
            }
        }

        SetNodeChanging(path, guid) {
            try {
                this.GetNode(path).ElementIsBeingModified(guid);
            } catch(error) {
                console.error("Could not set modifying because:", error);
            }
        }

        addNode(path, numericPath, value, isWritable) {
            try {
                if (this.nodes.hasOwnProperty(numericPath)) {
                    this.nodes[numericPath].Update(value);
                } else {
                    this.nodes[numericPath] = new EmberElement(path, numericPath, value, isWritable);
                }
            } catch(error) {
                console.error(error);
            }

            // Add new construction
            let pathArr = path.split("/");
            try {
                this.addNodeElement(this.nodes[numericPath], pathArr, this.treeRoot);
            } catch(error) {
                console.error(error);
            }
        }

        addNodeElement(emberElement, pathArr, currentPointer) {
            if (pathArr.length == 0) {
                return true;
            }
            if (currentPointer.hasOwnProperty(pathArr[0])) {
                // Have the position been added to the tree?
                // If yes then just point to that
                return this.addNodeElement(emberElement, pathArr.slice(1), currentPointer[pathArr[0]])
            } else {
                // There is no node at this position, so add a new node
                if (pathArr.length == 1) {
                    currentPointer[pathArr[0]] = emberElement;
                } else {
                    currentPointer[pathArr[0]] = new EmberNode(pathArr[0]);
                }
                return this.addNodeElement(emberElement, pathArr.slice(1), currentPointer[pathArr[0]])
            }
        }

        treeIdFromStringPath(path) {
            if (!path) {
                return "no_path_available";
            }
            return path.split("/").join("").toLowerCase().replace(" ", "_");
        }

        // GetNodeChildren(pathArr) {
        //     this.findNodeChildren(pathArr, this.treeRoot)
        // }

        // findNodeChildren(pathArr, currentPointer) {
        //     if (pathArr.length == 0) {
        //         return currentPointer;
        //     }
        //     if (currentPointer.hasOwnProperty(pathArr[0])) {
        //         // Have the position been added to the tree?
        //         // If yes then just point to that
        //         return this.findNodeChildren(emberElement, pathArr.pop(), currentPointer[pathArr[0]])
        //     } else {
        //         // There is no node at this position, so add a new node
        //         return false;
        //     }
        // }

        // treeIdParentFromStringPath(path, parentCount) {
        //     let arr = path.split("/");
        //     parentCount = parentCount || 1;
        //     arr.splice(-parentCount);
        //     return arr.join("").toLowerCase().replace(" ", "_");
        // }

        buildTreeView(tree) {
            try {
                let frag = document.createDocumentFragment();
                let arr = Object.entries(tree);
                for (let i = 0; i < arr.length; i++) {
                    // Build an object for each node
                    this.addNode(arr[i][0], arr[i][1].numericPath, arr[i][1].value, arr[i][1].isWritable);

                    // Add DOM objects
                    try {
                        let data = this.GetNode(arr[i][1].numericPath);

                        // Create first row
                        let tr = document.createDocumentFragment();
                        let li = document.createElement("TR");

                        // Add numeric path
                        let dvp = document.createElement("TD");
                        dvp.classList.add("tree-numeric-path");
                        dvp.innerHTML = `${data.numericPath} <span class="tree-node-name">${data.name}</span>`;
                        dvp.setAttribute("colspan", "3");
                        li.appendChild(dvp);

                        // Append first row
                        tr.append(li);
                        li = document.createElement("TR");

                        // Add path information
                        let dv1 = document.createElement("TD");
                        dv1.classList.add("tree-path");
                        dv1.innerHTML = data.GetHTMLReadablePath();
                        li.appendChild(dv1);

                        // Add actual values
                        let dv2 = document.createElement("TD");
                        dv2.classList.add("tree-value");
                        dv2.textContent = data.value;
                        dv2.setAttribute("data-key", new DataKey(data.numericPath, "text"));
                        dv2.setAttribute("data-id", data.numericPath);
                        li.appendChild(dv2);

                        // Add edit button
                        if (data.isWritable) {
                            let dvo = document.createElement("TD");
                            dvo.classList.add("tree-options");

                            if (typeof (data.value) === "string") {
                                let dvlink = document.createElement("A");
                                dvlink.classList.add("tree-option");
                                dvlink.textContent = "change";
                                let ofn = `emberChangeString(this,'${data.path}','${data.value}','${data.numericPath}')`;
                                dvlink.setAttribute("onclick", ofn);
                                dvo.append(dvlink);
                            }
                            if (typeof (data.value) === "number") {
                                let dvlink = document.createElement("A");
                                dvlink.classList.add("tree-option");
                                dvlink.textContent = "change";
                                let ofn = `emberChangeNumber(this,'${data.value}','${data.numericPath}')`;
                                dvlink.setAttribute("onclick", ofn);
                                dvo.append(dvlink);
                            }
                            if (typeof (data.value) === "boolean") {
                                let link = document.createElement("A");
                                link.classList.add("tree-option");
                                link.setAttribute("data-key", new DataKey(data.numericPath, "class", "state-on"));
                                link.setAttribute("data-id", data.numericPath);
                                link.textContent = "toggle";

                                if (data.value) {
                                    link.classList.add("state-on");
                                }

                                let ofnfalse = `emberToggleBoolean(this,'${data.numericPath}')`;
                                link.setAttribute("onclick", ofnfalse);
                                dvo.append(link);
                            }
                            li.appendChild(dvo);
                        } else {
                            let dvo = document.createElement("TD");
                            dvo.classList.add("tree-options");
                            let dvlink = document.createElement("SPAN");
                            dvlink.classList.add("tree-option");
                            dvlink.classList.add("non-writable");
                            dvlink.textContent = "change";
                            dvo.append(dvlink);
                            li.appendChild(dvo);
                        }

                        li.id = "id_row_" + this.treeIdFromStringPath(data.path);
                        tr.append(li);
                        frag.prepend(tr);
                    } catch(error) {
                        console.error(error);
                    }
                }

                // Setup UI-library callbacks
                this.onInitiated();
                return frag;
            } catch(err) {
                console.warn(err);
                return document.createDocumentFragment();
            }
        }

        updateInitialElements() {
            let elements = Object.entries(this.nodes);
            if (elements.length != 0) {
                elements.forEach((key, value) => {
                    this.updateDom(key[0], key[1].value);
                });
            } else {
                console.warn("No elements to update");
            }
        }

        updateNodeElement(path, value) {
            if (this.nodes.hasOwnProperty(path)) {
                this.nodes[path].Update(value);
                this.updateDom(path, value);
                return true;
            } else {
                return false;
            }
        }

        updateDom(path, value) {
            let selectedElements = document.querySelectorAll("[data-key]");
            selectedElements.forEach(function(item) {
                let obj = JSON.parse(item.dataset.key);
                if (obj.id === path) {
                    window.requestAnimationFrame(function() {
                        switch(obj.type) {
                            case "class":
                                if (value) {
                                    if (!item.classList.contains(obj.value)) {
                                        item.classList.add(obj.value);
                                    }
                                } else {
                                    item.classList.remove(obj.value);
                                }
                                break;
                            default:
                                // Actually update DOM node
                                item.innerHTML = value;
                                break;
                        }
                    });
                }
            });
        }

        /*
         * Matrices
         */
        buildMatrixView(path, matrix) {
            try {
                let frag = document.createDocumentFragment();
                let box = document.createElement("DIV");
                box.classList.add("tree-state-matrix");
                box.id = emberTree.treeIdFromStringPath(path);

                if (matrix.hasOwnProperty("sources") && matrix.hasOwnProperty("targets")) {
                    // Add matrix title label
                    let lbl = document.createElement("DIV");
                    lbl.classList.add("matrix-title");
                    lbl.style.gridColumn = `1 / span ${matrix.sources.length + 1}`;
                    lbl.textContent = matrix.name;
                    box.append(lbl);

                    // Add top left corner
                    let div = document.createElement("DIV");
                    div.classList.add("matrix-origo");
                    box.append(div);

                    // Add matrix
                    let sources = matrix.sources;
                    for (let i = 0; i < sources.length; i++) {
                        // Source label
                        let div = document.createElement("DIV");
                        div.textContent = sources[i].name;
                        div.classList.add("matrix-label--source");
                        div.setAttribute("data-key", new DataKey(this.treeIdFromStringPath(sources[i].labelPath)));
                        box.append(div);
                    }

                    let targets = matrix.targets;
                    for (let i = 0; i < targets.length; i++) {
                        // Target label
                        let div = document.createElement("DIV");
                        div.textContent = targets[i].name;
                        div.classList.add("matrix-label--target");
                        div.setAttribute("data-key", new DataKey(this.treeIdFromStringPath(targets[i].labelPath)));
                        box.append(div);

                        // Signals
                        for (let y = 0; y < sources.length; y++) {
                            let signal = document.createElement("DIV");
                            signal.classList.add("matrix-signal");
                            signal.classList.add("source_" + y);
                            signal.classList.add("matrix-signal_" + targets[i].index + "_" + this.treeIdFromStringPath(path));
                            signal.id = "id_signal_" + sources[y].index + "_" + targets[i].index + "_" + this.treeIdFromStringPath(path);

                            // Actually connect
                            if (targets[i].connectedSources.length !== 0) {
                                targets[i].connectedSources.forEach((item) => {
                                    if (item === sources[y].index) {
                                        signal.classList.add("matrix-signal--connected");
                                    }
                                });
                            }

                            box.append(signal);
                        }
                    }
                }

                box.style.gridTemplateColumns = `2fr repeat(${matrix.sources.length}, 1fr)`;
                frag.append(box);
                return frag;
            } catch(err) {
                console.warn(err);
                return document.createDocumentFragment();
            }
        }

        updateMatrixSignal(path, target) {
            // Remove all connected sources from target
            let targetBoxes = document.querySelectorAll(".matrix-signal_" + target.index + "_" + this.treeIdFromStringPath(path));
            targetBoxes.forEach(function(item) {
                item.classList.remove("matrix-signal--connected");
            });

            // Connect target with source
            for (let i = 0; i < target.connectedSources.length; i++) {
                document.getElementById("id_signal_" + target.connectedSources[i] + "_" + target.index + "_" + this.treeIdFromStringPath(path)).classList.add("matrix-signal--connected");
            }
        }
    }

    class EmberNode {
        constructor(nodeName) {
            this.nodeName = nodeName;
        }
    }

    class EmberElement {
        constructor(path, numericPath, value, isWritable) {
            this.path = path;
            this.numericPath = numericPath;
            this.readablePath = path.split("/").join("").toLowerCase().replace(" ", "_");
            this.name = this.getNodeNameFromPath(path);
            this.value = value;
            this.type = this.valueTypeToDefinition(value);
            this.isWritable = isWritable;

            this.$elements = Array.from(document.querySelectorAll(`[data-id='${this.numericPath}']`))
                .map((element) => new UIElement(element, this.type));

            this.Update(value);
        }

        ElementIsBeingModified(guid) {
            this.$elements.forEach((element) => {
                if (element.element.guid === guid) {
                    element.UserIsChanging();
                }
            });
        }

        Update(value) {
            this.value = value;

            if (this.$elements.length > 0) {
                this.$elements.forEach((item) => {
                    item.Update(this.value);
                });
            }
        }

        GetHTMLReadablePath() {
            return this.path.split("/").reduce((prev, curr) => {
                return `${prev} <span>${curr}</span>`;
            });
        }

        getNodeNameFromPath(path) {
            let split = path.split("/");
            if (Array.isArray(split)) {
                return split[split.length-1];
            } else {
                return "unknown";
            }
        }

        valueTypeToDefinition(type) {
            switch(typeof(type)) {
                case EMBER_NODE_TYPES.STRING:
                    return EMBER_NODE_TYPES.STRING;
                    break;
                case EMBER_NODE_TYPES.NUMBER:
                    return EMBER_NODE_TYPES.NUMBER;
                    break;
                case EMBER_NODE_TYPES.BOOLEAN:
                    return EMBER_NODE_TYPES.BOOLEAN;
                    break;
                default:
                    return EMBER_NODE_TYPES.UNKNOWN;
                    break;
            }
        }
    }

    class UserInterface {
        constructor() {

        }

        initiateListeners() {
            let $lsn = document.querySelectorAll("[data-event]");
            $lsn.forEach(function (elm) {
                try {
                    let item = elm.dataset.event.split(":") || ["click", elm.dataset.event];

                    console.log("Init listener for:", item);
                    console.log(emberTree.GetNode(item[1]));

                    // Generate unique element identification
                    elm.guid = createGuid();

                    switch (item[0]) {
                    case "click":
                        elm.addEventListener(item[0],
                            (event) => {
                                console.log("event click", event);
                                emberToggleBoolean(event.target, item[1]);
                            });
                        break;

                    case "pulse":
                        elm.addEventListener("click",
                            (event) => {
                                console.log("event pulse", event);
                                emberPulseBoolean(event.target, item[1]);
                            });
                        break;

                    case "input":
                        elm.addEventListener(item[0],
                            (event) => {
                                console.log("event input", event);

                                // Check if data-id is the same binding as event
                                // to determine what is actually being modified
                                // if (event.target.dataset.id && event.target.dataset.id !== item[1]) {
                                //     console.log(`Not same listener id ${item[1]} as data id ${event.target.dataset.id}`);
                                //     emberTree.SetNodeChanging(event.target.dataset.id, elm.guid);
                                // }

                                // Set actual value and say its changing
                                emberTree.SetNodeChanging(item[1], elm.guid);
                                emberChangeInt(event.target.value, item[1]);
                            });
                        break;

                    default:
                        console.warn(`Could not find event: '${item[0]}' to set up listener for with parameter: '${item[1]}'`);
                        break;
                    }
                } catch (error) {
                    console.error(error);
                }
            });

            emberTree.updateInitialElements();
        }
    }

    class UIElement {
        constructor(element, type) {
            this.element = element;
            this.elementType = element.nodeName.toLowerCase();
            this.guid = element.guid;
            this.type = type;

            this.isChanging = false;
            this.changingTimeout = null;

            // Set up text data
            if (this.element.dataset.text) {
                let text = this.element.dataset.text.split("|");
                if (text.length == 2) {
                    this.elementText = text;
                } else if(text.length == 1) {
                    text.push(text[0]);
                    this.elementText = text;
                }
            }

            // Set up style data
            if (this.element.dataset.style) {
                this.elementStyle = this.element.dataset.style;
            } else {
                this.elementStyle = "state-on";
            }

            // Set up visibility
            if (this.element.dataset.visibility) {
                this.elementVisibilityValue = this.element.dataset.visibility; // Should be flex, block or any display properties
                this.element.style.display = "none";
            }
        }

        UserIsChanging() {
            clearTimeout(this.changingTimeout);
            this.isChanging = true;
            this.changingTimeout = setTimeout(() => {
                this.isChanging = false;
                this.drawValue();
            }, 200);
        }

        Update(value) {
            this.value = value;
            this.setVisibility(this.value);
            switch(this.type) {
            case EMBER_NODE_TYPES.NUMBER:
                this.setValue(this.value);
                break;

            case EMBER_NODE_TYPES.BOOLEAN:
                this.setClass(this.value);
                this.setText(this.value);
                break;

            case EMBER_NODE_TYPES.STRING:
                this.setValue(this.value);
                break;

            default:
                console.warn(`Unknown EmBER+ type ${this.type}, will not update DOM`);
                break;
            };
        }

        /*
         * The node value changes, depending on type, different actions might be relevant
         */
        setValue(value) {
            if (!this.isChanging) {
                this.drawValue();
            }
        }

        drawValue() {
            window.requestAnimationFrame(() => {
                switch(this.elementType) {
                case "input":
                    this.element.value = this.value;
                    break;
                default:
                    this.element.innerHTML = this.value;
                    break;
                };
            });
        }

        setText(value) {
            if (this.elementText) {
                if (value) {
                    this.element.innerHTML = this.elementText[0];
                } else {
                    this.element.innerHTML = this.elementText[1];
                }
            }
        }

        setClass(value) {
            if (value) {
                this.element.classList.add(this.elementStyle);
            } else {
                this.element.classList.remove(this.elementStyle);
            }
        }

        setVisibility(value) {
            if (this.elementVisibilityValue) {
                if (value) {
                    this.element.style.display = this.elementVisibilityValue;
                } else {
                    this.element.style.display = "none";
                }
            }
        }
    }

    function createGuid() {
        function randNum() {
            return Math.floor((1 + Math.random()) * 0x10000).toString(16).substring(1);
        }
        return randNum() + randNum() + '-' + randNum() + '-' + randNum() + '-' + randNum() + '-' + randNum() + randNum() + randNum();
    }

    function DataKey(id, type, value) {
        this.id = id || "#";
        this.type = type || "#";
        this.value = value || "#";
    }

    DataKey.prototype.toString = function dogToString() {
        return JSON.stringify(this);
    }

    var emberTree = new EmberTree();
    emberTree.setup(() => {
        try {
            var ui = new UserInterface();
            ui.initiateListeners();
        } catch (error) {
            console.error(error);
        }
    });

    var connection = new signalR.HubConnectionBuilder()
        .withUrl("/larkspurHub")
        .withAutomaticReconnect()
        .build();

    setSocketConnectionFeedback("Disconnected");

    connection.on("InitialEmberTree", (tree) => {
        console.log(`Event 'InitialEmberTree':`, tree);
        try {
            let $doc = document.getElementById("treeInitialList") || document.createElement("TABLE");
            $doc.innerHTML = "";
            let $tbody = document.createElement("TBODY");

            let frag = emberTree.buildTreeView(tree);
            $tbody.append(frag);
            $doc.append($tbody);
        } catch (error) {
            console.error(error);
        }
    });

    connection.on("ChangesInEmberTree", (path, data) => {
        console.log(`Event 'ChangesInEmberTree', path:${JSON.stringify(path)}`);
        console.table(data);
        emberTree.updateNodeElement(data.numericPath, data.value);
    });

    connection.on("InitialEmberTreeMatrix", (matrices) => {
        console.log(`Event 'InitialEmberTreeMatrix': ${JSON.stringify(matrices)}`);
        let $doc = document.getElementById("matrixInitialTable") || document.createElement("DIV");
        $doc.innerHTML = "";
        let arr = Object.entries(matrices).sort();
        for (let i = 0; i < arr.length; i++) {
            let frag = emberTree.buildMatrixView(arr[i][0], arr[i][1]);
            $doc.append(frag);
        }
    });

    connection.on("ChangesInEmberTreeMatrix", (path, target) => {
        console.log(`Event 'ChangesInEmberTree', path:${JSON.stringify(path)}, target:${JSON.stringify(target)}`);
        emberTree.updateMatrixSignal(path, target);
    });

    var started;
    function reconnect() {
        clearTimeout(started);
        started = setTimeout(() => {
            connect();
        }, 3000);
    }

    function connect() {
        connection.start()
            .then(function () {
                setSocketConnectionFeedback(connection.connectionState);
                commandRequestInitialState();
            })
            .catch(function (err) {
                setSocketConnectionFeedback("Error " + err.toString());
                console.error(err.toString());
                reconnect();
            });
    }
    connect();

    connection.onclose(function() {
        console.log("connection onclose");
        setSocketConnectionFeedback(connection.connectionState);
        reconnect();
    });

    connection.onreconnecting(function(error) {
        console.log("connection onreconnecting", error);
        setSocketConnectionFeedback(connection.connectionState);
    });

    connection.onreconnected(function() {
        console.log("connection onreconnected");
        setSocketConnectionFeedback(connection.connectionState);
        commandRequestInitialState();
    });

    function commandRequestInitialState() {
        if (connection) {
            connection.invoke("RequestInitialState").catch((err) => {
                return console.error("Could not request initial state", err);
            });
        }
    }

    function setSocketConnectionFeedback(message) {
        document.getElementById("socketStatus").textContent = message;
    }

    function emberChangeString(element, path, value, numericPath) {
        let change = window.prompt(`Change string`, value);
        if (change !== null) {
            connection.send("ChangeEmberStringParameter", numericPath, change).catch((err) => {
                return console.error("Could not send change", err);
            });
        }
    }

    function emberChangeNumber(element, value, numericPath) {
        let change = window.prompt(`Change number`, value);
        if (change !== null) {
            connection.send("ChangeEmberNumberParameter", numericPath, parseInt(change)).catch((err) => {
                return console.error("Could not send change", err);
            });
        }
    }

    function emberChangeInt(value, numericPath) {
        connection.send("ChangeEmberNumberParameter", numericPath, parseInt(value)).catch((err) => {
            return console.error("Could not send change", err);
        });
    }

    function emberToggleBoolean(element, numericPath) {
        try {
            let item = emberTree.GetNode(numericPath);
            console.log(item);
            let state = !item.value; // inverse
            connection.send("ChangeEmberBooleanParameter", numericPath, state).catch((err) => {
                return console.error("Could not send change", err);
            });
        } catch(error) {
            console.error("EmberToggleBoolean: ", error);
        }
    }

    function emberPulseBoolean(element, numericPath) {
        try {
            connection.send("PulseEmberBooleanParameter", numericPath).catch((err) => {
                return console.error("Could not send change", err);
            });
        } catch(error) {
            console.error("EmberPulseBoolean: ", error);
        }
    }

    function emberChangeBool(value, numericPath) {
        if (element.dataset.id !== undefined) {
            try {
                let item = emberTree.GetNode(element.dataset.id);
                console.log(item);
                let state = !item.value; // inverse
                connection.send("ChangeEmberBooleanParameter", numericPath, state).catch((err) => {
                    return console.error("Could not send change", err);
                });
            } catch(error) {
                console.error("EmberChangeBool: ", error);
            }
        }
    }

</script>
</body>
</html>